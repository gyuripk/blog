# 인터페이스
title: 인터페이스
subtitle: 
categories: Java
tags: 스터디
date: 2021-04-14 20:22:39 +0000
last_modified_at: 2021-04-14 20:22:40 +0000
---

> 학습 목표 : 자바의 인터페이스에 대해 알아보자!

### 학습할 것

- 인터페이스를 정의하는 방법
- 인터페이스를 구현하는 방법
- 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법
- 인터페이스 상속

- 인터페이스의 기본 메소드(Default Method), 자바 8
- 인터페이스의 static 메소드, 자바 8
- 인터페이스의 private 메소드, 자바 9

---

## 인터페이스란?

일종의 추상클래스이지만 추상클래스보다 추상화정도가 더 높아 일반 메서드나 멤버변수를 가질 수 없다.  추상클래스와 상수만으로 구성되어 구현을 강제하는 역할을 한다. 인터페이스도 불완전 한 것이므로 그 자체로 객체를 생성해 사용할 수 없다.  

상속은 상속받아 기능을 확장하기 위해 쓴다. 

반면 인터페이스는 기능을 제한하기 위해 쓴다.(상속 처럼 쓸 순 있지만 그런 용도로는 사용하지 않는다.)

### 인터페이스를 사용하는 이유(장점)

1. 개발시간을 단축시킬 수 있다.
2. 표준화가 가능하다.
3. 서로 관계없는 클래스들에게 관례를 밎어 줄 수 있다.
4. 독립적인 프로그래밍이 가능하다. 

### 인터페이스 정의하는 방법

클래스 작성하는 것과 같고 키워드로 class대신 'interface'를 사용한다. 

접근제어자 public 또는 default를 사용할 수 있다. (생략가능)

```java
접근제어자 interface 인터페이스이름{
	public static final 타입 상수이름 = 값;
	public abstract void 메서드이름(매개변수목록);
}
```

### 인스턴스 멤버(멤버변수,메서드) 제약조건

- 모든 멤버변수는 public static final 이어야한다. (제어자 생략가능)
- 모든 메서드는 public abstract 이어야한다.(제어자 생략가능)
- 단, static메서드와 default 메서드는 예외(JDK 1.8부터)

제어자는 모든 인터페이스 멤버에 예외없이 적용되는 것이기 때문에 생략할 수 있다. 생략한 제어자는 컴파일 시에 컴파일러가 자동적으로 추가해준다. 

- JDK 1.8 이전 버전 : 추상클래스 + 상수 이렇게 두가지만 가질 수 있다.

```java
interface Exam01{
	/*
	 * CAN USE CASE
	 */
	public static final int T01 = 1; //Unnecessary modifiers 'public static final' on field 't01'
	public static int T02 = 2; //Unnecessary modifiers 'public static' on field 't02'
	public final int T03 = 3; //Unnecessary modifiers 'public final' on field 't03'
	final int T04 = 4; //Unnecessary modifiers 'final' on field 't04'
	static int T05 = 5;  //Unnecessary modifiers 'static' on field 't05'
	int T06 = 6;

	public abstract void test01(); //Unnecessary modifiers 'public abstract' on method 'test01'
	abstract void test02(); //Unnecessary modifiers 'abstract' on method 'test01'
	void test03();

	/*
	 * ERROR CASE
	 *
	 * public static final int T01; //Variable 'T01' might not have been initialized
	 * protected static int T02 = 2; //Illegal modifier for the interface field; only public, static & final are permitted
	 * private final int T03 = 3; //Illegal modifier for the interface field; only public, static & final are permitted
	 * 
	 * private void test01(); //Illegal modifier for the interface method; only public, private, abstract, default, static and strictfp are permitted
	 * protected void test02();
	 * void test03() { } //Abstract methods do not specify a body
	 */

}
```

[주의!] 원래는 인터페이스의 모든 메서드는 추상메서드여야 했다. 하지만 JDK1.8부터 인터페이스에 static메서드, default 메서드의 추가를 허용하도록 변경되었다. 변경전의 규칙와 이후의 규칙을 모두 알고 있어야 한다.  

### 인터페이스 상속

인터페이스는 인터페이스로부터만 상속받을 수 있고, 클래스와 달리 다중상속이 가능하다. 클래스의 상속과 마찬가지로 조상인터페이스의 멤버(멤버변수, 메서드)를 모두 상속받아 사용할 수 있다.  (정확히는 구현, 다중구현이라고 표현하는 것이 더 적절할 것 같다.)

```java
interface Fighterable extends Movable, Attackable{}
interface Movable{ void move(int x, int y); }
interface Attackable{ void attack(Unit u); }
```

하나의 클래스에 여러개의 인터페이스를 구현할 수 있다. 서로 다른 인터페이스에 같은 추상 메서드가 있어도 문제가 없다. 어차피 구현되어있지 않기 때문에 , 똑같은 메서드를 상속 받아도 한 번만 구현하면 문제 없기 때문이다.

```java
public class Exam02 implements MyInterface_02, MyInterface_03, MyInterface_04 {
	void test(){
		System.out.println("한 번만 오버라이딩 하면 된다.");
	}
}

interface MyInterface_02{ void test(); }
interface MyInterface_03{ void test(); }
interface MyInterface_04{ void test(); }
```

### 인터페이스 구현하는 방법

추상클래스처럼 인터페이스 자체로는 미완성메서드를 포함하기 때문에 인스턴스를 생성할 수 없다. 그래서 정의된 추상메서드를 구현하는 클래스를 작성해야만 인스턴스를 생성할 수 있다. 구현한다는 의미에서 'implements' 키워드를 사용한다.  

```java
class 클래스이름 implements 인터페이스이름 {
	// 인터페이스에 정의된 메서드를 구현해야한다.
}
```

인터페이스의 메서드를 오버라이딩해 준다.

```java
class Fighter implements Fightable{
	public void move(int x, int y){ /*내용 구현*/ };
	public void attack(Unit u){ /*내용 구현*/ };
}

//인터페이스 메서드 중 일부만 구현한다면 abstract 붙여서 추상클래스로 선언해야 한다.
abstract class Fighter implements Fightable{
	public void move(int x, int y){ /* 내용 구현*/ };
	//attack() 메서드 구현하지 않았음
}
```

[주의!] 

인터페이스에선 컴파일러가 자동으로 메서드 앞에 public붙여주지만 클래스에서는 public명시하지 않으면 default가 된다. 오버라이딩 할 때는 조상의 메서드보다 넓은 범위의 접근 제어자를 지정해야하므로 public → default로 좁은 범위로 제한 하는 것은 컴파일 에러가 발생한다. (error : Cannot reduce the visibility of the inherited method from Movable)

 즉, 인터페이스의 메서드를 받아 구현할 때는 반드시 접근 제어자를 public으로 해야 한다.

### 인터페이스 레퍼런스를 통해 구현체를 사용하는 방법 → (인터페이스를 이용한 다형성)

다형성 : 조상 타입의 참조변수로 자손 인스턴스를 참조할 수 있도록 하는 것.

인터페이스를 상속 받았는데 추상메서드를 구현하지 않으면 (오버라이딩 하지 않으면) 다음과 같은 컴파일 오류를 발생한다. 

![%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2000281e81d5564bf49aef6cebf8a7d60f/_.png](%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%90%E1%85%A5%E1%84%91%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%89%E1%85%B3%2000281e81d5564bf49aef6cebf8a7d60f/_.png)

해결하기 위해서 메서드를 오버라이딩 하거나, MyClass_01 앞에 abstract 키워드를 붙여 추상클래스임을 나타내줘야한다.

```java
public class InterfaceTest {
	public static void main(String[] args) {
		MyClass_01 mc01 = new MyClass_01();
		MyClass_02 mc02 = new MyClass_02();
		
		// 참조변수 mc01, mc02의 클래스 모두 MyInterface 인터페이스를 상속 받았기 때문에 이처럼 배열로 묶어서 관리할 수 있다.(다형성)
		MyInterface[] mi = { mc01, mc02 }; //객체 배열(참조 주소를 저장)
		
		for (MyInterface myInterface : mi) {
			myInterface.mustBeInvoked();
		}
	}
}

interface MyInterface { 
//The public type MyInterface must be defined in its own file
	void mustBeInvoked();
}

class MyClass_01 implements MyInterface{
	@Override //어노테이션 사용하는 것 권장함(생략 가능)
	public void mustBeInvoked() {
		System.out.println("MyClass_01");
	}
}

class MyClass_02 implements MyInterface{
	@Override
	public void mustBeInvoked() {
		System.out.println("MyClass_02");
	}
}
```

<실행 결과> 

MyClass_01

MyClass_02

---

## 인터페이스의 메서드

### 인터페이스의 기본 메서드(default Method) - 자바8

- default method

디폴트 메서드는 키워드 default를 붙이고 접근제어자는 public(생략가능)이며, 구현부{ }가 있어야 한다. 

이 메서드가 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.

그렇다면 디폴트 메서드는 왜 생겼을까? 

인터페이스에 메서드를 추가한다고 할 때, 이 인터페이스를 구현한 기존의 모든 클래스들이 강제로 새로 추가된 메서드를 구현해야한다. 그리고 추가되는 메서드를 사용하지 않는 클래스들까지도 아무것도 하지 않는 비어있는 실행 블록을 작성해야하는 상황이 올 수도 있다.

이런 상황에 클래스에서 인터페이스 내부의 메소드를 선택적으로 오버라이딩 해서 사용할 수 있도록

즉, 굳이 오버라이딩 하지 않아도 컴파일 오류가 발생하지 않는 메소드를 인터페이스에 추가하기 위해서 만든 것이 default 메소드이다. 

```java
class test implements MyInterface {
	void method(){
		System.out.println("추상 메서드 구현");
	}
	//인터페이스 내부 메소드인 newMethod를 구현하지 않아도 오류가 발생하지 않는다.
}

interface MyInterface {
	void method(); //추상 메서드
	default void newMethod(){ //디폴트 메서드
		System.out.println("인터페이스도 구현 메서드를 가질 수 있게 되었다!");
  } 
}
```

### 인터페이스의 static 메서드 - 자바8

- (public) static method

인터페이스의 static 메서드도 클래스의 멤버에 static 키워드를 붙인 것과 같이, 인터페이스 이름으로 바로 접근해서 사용할 수 있다. 그리고 역시 접근 제어자는 항상 public이다.(생략가능)

그리고 인터페이스의 static메소드는 오버라이딩 할 수 없다.

```java
class test{
	public static void main(String[] args) {
		MyInterface.method();
	}
}

interface MyInterface {
	static void method(){
		System.out.println("static method!");
	}
}
```

결과 : static method!

### 인터페이스의 private 메서드 - 자바9

자바 9에서는인터페이스에서 private 메서드를 사용할 수 있게 되었다.

- private method
- private static method

```java
interface MyInterface_02 {

	default void default_method() {
		System.out.println("default method");
		private_method(); //private 메서드 사용가능
		static_method(); //static 메서드 사용가능
	}
	
	private void private_method() {
		System.out.println("private method");
		static_method();
		private_static_method();
	}
	
	static void static_method() {
		System.out.println("static method");
		private_static_method(); //private static 메서드 사용가능
		//default_method();  
		//private_method();  
		//다른 일반 메서드 사용 불가능
		//Cannot make a static reference to the non-static method default_method() from the type MyInterface_02
	}
	
	private static void private_static_method() {
		System.out.println("private static method");
		//default_method();
		//private_method();
		//다른 일반 메서드 사용 불가능
	}
	
}
```

---

## 전략 패턴

---

- 참고

    [https://blog.naver.com/hsm622/222201314752](https://blog.naver.com/hsm622/222201314752)

    자바의 정석