---
title: Untitled
subtitle: "예외처리에 대해서 알아보자!"
categories: Java
tags: study
date: 2021-05-02 04:04:14 +0000
last_modified_at: 2021-05-02 04:04:14 +0000
---
# Untitled

> 학습 목표 : 자바의 예외 처리에 대해 알아보자!

## 프로그램 오류

프로그램 실행 중 오작동, 비정상적 종료의 원인을 프로그램 에러 또는 오류라고 한다. 

### 발생 시점에 따른 분류

- 컴파일 에러

    컴파일 시에 발생하는 에러 → 소스코드(.java)를 컴파일러가 구문, 자료형 체크 등의 검사를 통해 오류가 있는지 알려준다.

- 런타임 에러

    프로그램의 실행도중에 발생하는 에러 → 컴파일이 완료되면 바이트코드(.class)가 생성되고 이 클래스파일을 실행한다. → 실행시 발생할 수 있는 프로그램 오류를 뜻한다. 

    실행도중 발생할 수 있는 모든 경우의 수를 생각하여 런타임 에러를 대비해야한다. 

### 그 외

- 논리적 에러

    실행은 되지만, 의도와 다르게 동작하는 것

### Exception와 Error의 차이는?

### 예외 (Exception)

- 프로그램 코드에 의해서 수습될 수 있는덜 심각한 오류
- 프로그램 코드레벨에서 문제 생겼을 경우 발생
- 프로그래머가 적절한 코드를 미리 작성해 놓음으로써 프로그램의 비정상적인 종료를 막을 수 있다.

### 에러 (Error)

- 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
- JVM에 문제가 생겼을 경우 발생
- 일단 발생하면 프로그램의 비정상적인 종료를 막을 수 없다.

## 자바가 제공하는 예외클래스 계층 구조

자바에서는 발생할 수 있는 오류(Error와 Exception)를 클래스로 정의했다. 모든 클래스의 조상은 Object이므로 Exception과 Error 클래스도 Object의 자손들이다. 모든 예외의 최고조상은 Exception클래스이다.

![Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled.png](Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled.png)

![Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled%201.png](Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled%201.png)

## RuntimeException과 RE가 아닌 것의 차이는?

### checked Exception
(RE아닌 Exception클래스들)

- 외적인 요인에 의해 발생하는 예외
- 컴파일러가 예외처리를 확인하는 Exception클래스들
- 반드시 예외처리(try-catch또는 throws) 해줘야함(필수적)→ 안 해주면 컴파일 오류 발생
- 일반적으로 메서드에 trows로 명시해준다.
- 컴파일 할 때 발생하며, 미리 알 수 있다.(컴파일 에러)

### unchecked Exception
(RuntimeException클래스들)

- 프로그래머의 실수로 발생하는 예외
- 컴파일러가 예외처리를 확인하지 않는 RuntimeException클래스들
- 필요에 따라 예외처리 해줘야함(선택적)
- 프로그램 실행 중에 발생하며, 발생할 것을 미리 알 수 없다.(런타임 에러)

## 예외 처리(Exception Handling)

### 예외 처리란?

프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성하는 작업이다.

- 예외처리를 하는 이유는?

발생한 예외를 처리하지 못하면 프로그램은 비정상적으로 종료되기 때문에, 정상적인 실행상태를 유지하기위해서 미리 예외처리 작업을 한다.

## 자바에서 예외를 처리하는 방법

### try - catch 문

try{ }에 예외가 발생될 가능성이 있는 문장을 적고 catch{ }에 예외를 처리할 문장을 적는다. 

하나의 try블럭 다음 하나 이상의 catch블럭이 올 수 있으며, 발생한 예외의 종류와 일치하는 단 한 개의 catch블럭만 수행한다. 

그리고 하나의 메서드 안에 여러 개의 try-catch문이 사용될 수 있고, try나 catch 안에 또 다른 try-catch문에 포함될 수 있다.

### finally블럭

예외 발생여부와 상관없이 실행되어야할 코드를 포함시키기 위해 사용하는 블럭이다.   try-catch문의 끝에 선택적으로 덧붙여 사용한다. 

[참고] try나 catch블럭에 return문이 실행되는 경우에도 finally블럭을 먼저 수행 후, 현재 실행 중인 메서드를 종료한다. 

```java
try{
	// 예외가 발생할 가능성이 있는 문장들을 작성 -> 오류발생하면 '예외 객체'가 생성된다.
} catch (Exception1 e1) { //생성된 예외객체와 참조변수가 일치하는지 확인
	// 예외 Exception1 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
} catch (Exception2 e2) {
	// 예외 Exception2 이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
} finally {
	// 예외발생 여부와 상관없이 수행되는 문장
}

try{
	try{  } catch (Exception e) {  }
} catch (Exception1 | Exception2 e) { //멀티 catch블럭 
	try{  } catch (Exception e1) {  }
}
```

### 실행 순서

![Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled%202.png](Untitled%20edf052cf637d4eebb94222ef61e72063/Untitled%202.png)

### try블럭 안에서 예외가 발생하지 않은 경우

1. catch블럭을 거치지 않고 try-catch문을 빠져나간다.
2. finally블럭이 있다면 해당 블럭의 내용을 수행한 후 그 다음 문장을 계속 수행한다.
finally블럭이 없다면 그 다음 문장을 계속 수행한다.

### try블럭 안에서 예외가 발생한 경우

1. try블럭 안에서 예외가 발생하면 발생한 예외에 해당하는 클래스의 인스턴스가 생성된다. 
2. 이 예외를 처리할 수 있는 catch블럭이 있는지 찾는다.발생한 예외와 일치하는 catch블럭이 있는지 확인한다.
    - catch블럭의 괄호( )내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스를 `instanceof`연산자를 이용해 검사한다. 검사 결과가 true인 catch블럭을 찾을 때까지  계속 검사한다.
3. 검사결과가 true인 catch블럭을 찾으면, 해당 블럭의 문장들을 모두 수행한 후에 try-catch문을 빠져나가 예외가 처리된다. 
하지만 검사결과가 true인 catch블럭이 하나도 없을 경우, 예외는 처리되지 못하고 프로그램을 비정상적으로 종료시킨다.

[주의!] try 안에서 예외가 발생하면, 그 이후의 try블럭의 문장들은 수행되지 않으므로, try 블럭에 포함시킬 코드의 범위를 잘 선택해야 한다. 

[참고] 모든 예외 클래스는 Exception의 자손이므로 catch블럭 괄호( )에 Exception클래스 타입의 참조변수를 선언하면 어떤 종류의 예외가 발생하더라도 이 catch블럭에서 처리된다. 

- `printStackTrace()`

    예외발생 당시의 호출스택(Call stack)에 있었던 예외 메시지와 메서드 정보를 화면에 출력한다.

- `getMessage()`

    발생한 예외 클래스의 인스턴스에 저장된 메시지를 얻을 수 있다. 

    이러한 메서드들을 통해 예외의 발생원인을 파악할 수 있다.

```java
public class ExceptionEx7 {

	public static void main(String[] args) {
		System.out.println(1);
		System.out.println(2);
		
		try {
			System.out.println(3);
			System.out.println(0/0); //예외 발생 -> ArithmeticException예외 객체 생성됨
			System.out.println(4); //실행되지 않는다.
		}catch (ArithmeticException e) {
			if(e instanceof ArithmeticException) {
				System.out.println("true");
				System.out.println("ArithmeticException 발생함!");
			}
			e.printStackTrace();  //참조변수 e를 통해 생성된 예외객체에 접근할 수 있다.
			System.out.println("예외 메시지 :" + e.getMessage());
		}catch (Exception e) { //ArithmeticException을 제외한 모든 예외가 처리됨
			System.out.println("Exception 발생함!");
		}

		System.out.println(6);
	}

}
```

<실행 결과>

1
2
3
true
ArithmeticException 발생함!
java.lang.ArithmeticException: / by zero
at ch8.ExceptionEx7.main(ExceptionEx7.java:11)
예외 메시지 :/ by zero
6

---

### try - catch - resource 문 (자동 자원 해제)

try( ) 안에 close()가 필요한 객체를 생성하면, try{ }블럭이 종료될 때 jvm이 자동으로 close()처리를 해 자원을 반환(해제)해준다. 즉, 따로 finally블록이나 모든 catch블록에 close() 처리를 하지 않아도 된다. 그래서 주로 입출력 관련 클래스, db커넥션 클래스 등의 close가 필요한 객체를 구현해야 할 때 유용하게 쓰인다.

단, try( )에서 선언된 객체가 AutoCloseable 인터페이스를 구현한 것이어야만 한다.

- 사용하는 이유는?

명시적으로 close를 호출하려면 많은 if와 try-catch를 사용해야 하기 때문에 코드가 복잡해지고 close를 빼먹는 경우가 생긴다. 이러한 단점을 개선하여 코드를 간결하게 만들어 가독성을 높이고 유지보수를 쉽게 하고자 함이다.

```java
public class TryCatchResourceEx {
//파일 쓰기
	public static void main(String[] args) {
		try( 
			FileWriter fr = new FileWriter("testFile.txt");
			BufferedWriter bw = new BufferedWriter(fr)
		){
			bw.write("hello");
			bw.newLine(); //줄 바꿈
			bw.write("write something");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

}
```

[참고] 자바9부터는 try( )안에 객체를 생성하지 않고 명시만 해주는 것도 가능하다. 

```java
FileWriter fr = new FileWriter("testFile.txt");
BufferedWriter bw = new BufferedWriter(fr);
try(fr; bw){
	//...
}
```

---

### throw 키워드

예외 발생시키는 키워드로 프로그래머가 고의로 예외를 발생시킬 수 있다.

1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든다.

    `Exception e = new Exception("고의로 발생시킴!");`

2. 키워드 throw를 이용해서 예외를 발생시킨다.

    `throw e;`

이렇게 한 줄로 줄여 쓸 수 있다.

`throw new Exception("고의로 발생시킴!");`

### throws 키워드

메서드 내에 예외를 선언할 때 사용하는 키워드로,

메서드 선언부에 throws키워드를 사용해 메서드 내에서 발생할 수 있는 예외를 적어준다. 여러개일 경우 (,)로 구분한다

- 사용하는 이유는?

메서드를 사용하는 사람이 메서드의 선언부를 보고, 이 메서드를 사용하기 위해 어떤 예외들이 처리되야하는지 쉽게 알 수 있다. → 프로그래머가 편리하고, 견고한 프로그램 코드를 작성할 수 있다. 

```java
void method() throws Exception1, Exception2, Exception3 {
	//메서드 내용
} 
```

메서드에서 발생하는 예외를 해당 메서드를 호출한 메서드에서 예외처리하도록 넘기는 역할을 한다.

예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신을 호출한 메서드에게 (예외를 전달하여) 예외 처리를 떠넘기는 것이다. 결국 어느 한 곳에서는 반드시 try-catch로 예외처리를 해줘야 한다. 

```java
public class ExceptionEx14 {

	public static void main(String[] args) {
		try {
			method1();
		} catch (Exception e) {
			System.out.println("main메서드에서 예외가 처리되었습니다.");
			e.printStackTrace();
		}
	}

	static void method1() throws Exception{
		throw new Exception();
	}
}
```

<실행 결과>

main메서드에서 예외가 처리되었습니다.
java.lang.Exception
at ch8.ExceptionEx14.method1(ExceptionEx14.java:15)
at ch8.ExceptionEx14.main(ExceptionEx14.java:7)

[주의!] 예외를 발생시키는 throw 키워드와 헷갈리지 말 것!

---

## 커스텀한 예외 만드는 방법(사용자 정의 예외 만들기)

기존에는 주로 Exception을 extends하여 'checked 예외'로 만들었다. 하지만 요즘에는 예외처리를 선택적으로 할 수 있는  RuntimeException(unchecked)를 extends하여 'unchecked 예외'로 만드는 추세다.

checked 예외 상황을 만들 경우 RE아닌 Exception클래스들을, unchecked 예외 상황을 만들 경우 RuntimeException클래스들을 상속받아 만들면 된다. 필요에 따라 알맞은 예외 클래스를 선택하면 된다.

```java
class checkedException extends Exception{ //IOException
	checkedException(String msg){
		super(msg);
	}
}

class uncheckedException extends RuntimeException{ //NullPointerException
	uncheckedException(){
		super();
	} 
}
```

---

- 참고

    [http://www.btechsmartclass.com/java/java_images/java-exceptions-class-hierarchy.jpg](http://www.btechsmartclass.com/java/java_images/java-exceptions-class-hierarchy.jpg)

    [https://madplay.github.io/post/java-checked-unchecked-exceptions](https://madplay.github.io/post/java-checked-unchecked-exceptions)

    [https://velog.io/@khsb2012/java-study-week9](https://velog.io/@khsb2012/java-study-week9)

    [https://opentutorials.org/course/1223/6226](https://opentutorials.org/course/1223/6226)

    [https://imasoftwareengineer.tistory.com/86](https://imasoftwareengineer.tistory.com/86)

    [http://www.tcpschool.com/lectures/img_java_exception_intro.png](http://www.tcpschool.com/lectures/img_java_exception_intro.png)

    [https://codechacha.com/ko/java-try-with-resources/](https://codechacha.com/ko/java-try-with-resources/)